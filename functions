#!/bin/bash
#
# Misc. functions and Load helper functions
#
# @package profile
# @author  Martin Proffitt <mproffitt@choclab.net>
# @link    http://www.choclab.net/

for file in $(ls ~/.bashprofile/function-modules | grep -v 'disabled\|README') ; do
    source ~/.bashprofile/function-modules/$file;
done

##
# Reload bash_profile
#
function resource()
{
    if ps aux | grep -v grep | grep powerline-daemon &>/dev/null ; then
        kill -SIGKILL $(ps aux | grep -v grep | grep powerline-daemon | awk '{print $2}')
    fi
    clear && reset && source ~/.bashrc;
}

##
# Lists all defined aliases on the current shell
#
# @return void
#
function defaliases()
{
    alias | sed 's/=/ /g' | cut -d\  -f2
}

##
# Lists all defined symbolic links in the given directory
#
# @param string directory The directory to list
#
# @return void
#
function lss()
{
    local directory=$1;
    ls -lah $directory | grep "^l";
}

##
# Searches all files under the current directory for the given string of text
#
# @param mixed @ The string or regex to search for
#
# @return void
#
function findinfile()
{
    local FILES=();

    for arg in $@; do
        if [[ "$arg" =~ ^(\*|[a-zA-Z0-9])\.[a-zA-Z0-9]{2,4}$ && $# -gt 1 ]] ; then
            FILES+=($arg)
            shift
        fi
    done

    local names='';
    for file in ${FILES[@]}; do
        names="$names -o -name $file"
    done
    names=$(echo $name | sed 's/^ -o //')
    find -P '.' -type f -print -follow | sed "s/ /\\\ /g" | xargs grep -in --color "$@";
}

##
# Clears the screen and changes to a given directory
#
# @param directory string
#
function ccd()
{
    clear;
    /usr/bin/cd "$@";
}

##
# search ps listing without showing ps of grep
#
# @param string args [optional]
# @param string application
#
function psof()
{
    local ps_args='aux';
    if [ $# -eq 2 ]; then
        if [ "$1" != '' ]; then
            ps_args="$1";

        fi
        shift;
    fi

    local cmd=$(echo $1 | sed 's/^\([a-z]\)/\[\1\]/');
    eval "ps $ps_args | grep $cmd";
}

##
# Get the process ID[s] of a given command
#
# @param name string
#
function psonly()
{
    oldIFS=$IFS;
    IFS=$'\n';
    for line in $(psof $1); do
        echo $line | awk '{print $2}';
    done
    IFS=$oldIFS;
}

##
# Launches an application after 10 seconds (with countdown)
#
# @param command string The command and arguments to execute
#
# @return LAST_EXIT_STATUS
#
function x()
{
    seq 10 | sort -rn | xargs -I{} sh -c 'figlet {}; sleep 1';
    eval "$@";
    return $?;
}

##
# Onto a given host as a user
#
# @param host string
# @param user string
#
# [deprecated] Use waitssh instead
#
function onto()
{
    if [ $# -le 1 ] || [ $# -gt 2 ] ; then
        error "Usage: onto <host> <user>"; return 1;
    fi;

    if [ -z $1 ] ; then error "No host provided."; return 1; fi;
    local host=$1;

    local user=$2;
    local sshUser="";
    if [ -z $user ] ; then
        grep -q $host '^jenkins' && sshUser='jenkins';
        if [ -z $sshUser ] && echo "jira confluence fisheye sonar nexus" | grep -q $user; then
            sshUser='root';
        fi
    fi;

    if ! grep -q $host ~/.ssh/config; then
        if ! grep -q $host /etc/hosts; then
            error "Invalid host name for SSH connection" && return 1;
        else
            host=$(grep $host /etc/hosts | awk '{print $NF}');
        fi
    fi
    ssh $user@${host};
}

##
# Launch PyClewn debugger
function vdb()
{
    pyclewn --gdb="async" --args="--args $@" --cargs='-c "runtime misc/pclewn.vim" -c "call PyClewnPre()"'
}

##
# Shows a spinner for long running tasks
#
# @param pid int The process ID to monitor
#
function spinner()
{
    local pid=$1;
    local string=$2;
    local delay=0.75;
    local spinstr='|/-\';
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?};
        printf "$string [%c]  \r" "$spinstr";
        local spinstr=$temp${spinstr%"$temp"};
        sleep $delay;
    done
    echo;
}

##
# Builds a latex file using pdflatex and opens it in the system default pdf reader
#
function buildtex()
{
    clear;
    local file="";
    [ -z $1 ] && { echo "<file> is required" && return 1; };
    file=$1;

    [ ! -f $file ] && { echo "$file must exist" && return 1; };
    [ ! -d build ] && mkdir build;

    {
        for i in {1..4}; do
            pdflatex --output-dir=build $file 1>/dev/null;
        done 2>/dev/null &
        spinner $! "Building: $(echo $file | sed 's/.tex$//; s/_/ /g')";
    } 2>/dev/null;
    open build/$(echo $file | sed 's/tex$/pdf/');
}

##
# Sets the window title
#
# @param title
#
function settitle()
{
    name=$(basename `pwd`)
    if [ ! -z "$1" ]
    then
        name="$1"
    fi
    printf "\033k$name\033\\ "
}

##
# Waits for an ssh connection to become available
#
# @param server
#
function waitssh()
{
    local user='root'
    local server=$1
    if [ ! -z "$2" ] ; then
        user="$2"
    fi
    until ssh "${user}@${server}" 2>/dev/null; do
        echo -n '.';
        sleep 0.1;
    done
}

##
# Executes nuget.exe using mono
#
# @param args list
#
function nuget()
{
    local args="$@"

    mono ${HOME}/bin/nuget/nuget.exe $args
}

##
# Compares two sets of strings
#
function diffstrings()
{
    echo "$1" > /tmp/diff01.txt;
    shift;
    echo "$1" > /tmp/diff02.txt;
    shift;

    args='';
    if [ ${#@} -gt 0 ] ; then
        args="$@";
    fi
    diff $args /tmp/diff01.txt /tmp/diff02.txt;
    rm /tmp/diff01.txt /tmp/diff02.txt;
}

##
# Helper function for port forwarding a remote server
#
function sshport()
{
    local localport=0
    local remoteport=0
    local server=''
    local sshport=22
    local user=$(whoami)

    if [ $# -lt 2 ]; then
        warn 'Usage: `sshport <host> <port>`' >&2
        warn '       `sshport <host> <remote_port> <local_port>`'
        return 1
    fi

    local regex='^[0-9]+$'
    while [ $# -ne 0 ] ; do
        current="$1"
        shift
        if [[ "$current" =~ $regex ]]; then
            [ $remoteport -eq 0 ] && remoteport=$current || localport=$current
        elif [ "$current" = '-p' ] ; then
            current="$1"
            shift
            if [[ "$current" =~ $regex ]]; then
                sshport=$current
            fi
        elif [ "$current" = '-u' ] ; then
            user="$1";
            shift
        else
            server=$current
        fi
    done
    [ $localport -eq 0 ] && localport=$remoteport

    local valid=0
    if [ $remoteport -eq 0 ]; then
        error "Invalid remote port specified"
        valid=1
    fi

    if [ $localport -eq 0 ] ; then
        error "Invalid local port specified"
        valid=1
    fi

    if [ ! $valid ] ; then
        return 1
    fi

    # Check that the host is listening for SSH connections
    if ! </dev/tcp/$server/$sshport ; then
        error "Server '${server}' is not listening on '${sshport}'"
        return 1
    fi

    inform "Waiting for SSH connection to $localport:$user@$server:$remoteport"
    until ssh -NTCf -L $localport:localhost:$remoteport $user@$server -p $sshport; do
        echo -n '.';
        sleep 0.1;
    done
    pid=$(ps aux | grep "$localport:localhost:$remoteport $user@$server -p $sshport" | grep -v grep | awk '{print $2}')
    inform "SSH connection up and running on process id $pid"
}

##
# Set up a proxy to jupyter notebook running on a galaxy far far away...
#
function callisto()
{
    ssh -NTCf -L 3129:localhost:3128 -R 0.0.0.0:3129:localhost:3128 nebula.home.net
}

##
# Kills all docker containers
#
function dkill()
{
    for name in $(docker ps | awk '{print $NF}' | tail -n+2); do
        inform "Stopping docker container $name"
        docker stop $name &>/dev/null
    done

    for name in $(docker ps -a | awk '{print $NF}' | tail -n+2); do
        inform "Deleting docker container $name"
        docker rm $name &>/dev/null;
    done
}

##
# deletes all docker images
#
function dkillall()
{
    dkill;
    for id in $(docker images | awk '{print $3}' | tail -n+2); do
        inform "Deleting docker image $id"
        docker rmi -f $id;
    done
}

##
# Sets the proxy server according to the settings in ~/.bashprofile/private-modules/proxy.bash
#
function proxy()
{
    source ~/.bashprofile/private-modules/proxy.bash
}

##
# Unsets the proxy server
#
function noproxy()
{
    unset http_proxy
    unset https_proxy
    unset no_proxy
    unset HTTP_PROXY
    unset HTTPS_PROXY
    unset NO_PROXY
}

##
# Helper function to pull vsphere credentials from terraform file and pass to govc
#
function gvc()
{
    cd /opt/terraform
    if [ ! -f variables.tf ] && [ ! -d .git ]; then
        echo "This function must be executed from terraform repo root" >&2
        cd -
        return 1
    fi
    GOVC_URL="https://$(grep -A1 vsphere_server variables.tf | grep default | awk '{print $NF}' | sed 's/"//g')/sdk" \
    GOVC_USERNAME="$(grep vsphere_user terraform.tfvars | awk '{print $NF}' | sed 's/"//g')" \
    GOVC_PASSWORD="$(grep vsphere_password terraform.tfvars | awk '{print $NF}' | sed 's/"//g')" \
    govc "$@"
    rc=$?
    cd - &>/dev/null
    return $rc
}

function mapbranch()
{
    local branch=$(git name-rev HEAD | awk '{print $NF}')
    case ${branch} in
        'sandbox')
            echo ${branch}
            ;;
        'develop')
            echo 'dev'
            ;;
        'master')
            echo 'test'
            ;;
    esac
}

##
# Switch to a different kubernetes environment
#
function onkube()
{
    local environments="sandbox dev test stage prod"
    local environment=$1
    if [ ! -d ~/.kube/${environment} ]; then
        mkdir ~/.kube/${environment}
    fi

    local stackname="sec-isecops-${2}-stack"
    if [ -z "${environment}" ] || ! contains ${environment} ${environments} ; then
        echo "usage onkube [${environments}] <stackname>"
        return
    fi
    if [ "${stackname}" != "${KUBECONFIG}" ]; then
        export KUBECONFIG=~/.kube/${environment}/${stackname}.config
        echo "Loaded ${KUBECONFIG}"
        awssetup ${environment}
    fi
    killall kubectl
    dashboard
}

function awssetup()
{
    local environment=$1
    unset AWS_DEFAULT_REGION
    unset AWS_ACCESS_KEY_ID
    unset AWS_SECRET_ACCESS_KEY
    if [ "${environment}" != 'local' ]; then
        inform "Loading AWS Environment ${environment}"
        eval $(aws-env mss${environment})
        export AWS_DEFAULT_REGION=$(grep -A1 'mss'${environment}']' ~/.aws/config | sed '1d;s/.*=\(.*\)/\1/')
    fi
}

function tfinit()
{
    rm -rf .terraform
    local configpath="config/backend/aws"
    if [ ! -d "${configpath}" ]; then
        configpath="../${configpath}"
    fi
    $(which terraform) init -backend-config=${configpath}/${environment^^}.config
    if ! $(which terraform) workspace select ${environment} ; then
        $(which terraform) workspace new ${environment}
    fi
}

function tf()
{
    local cwd=$(pwd)
    # switch to the actual terraform directory
    # TODO Query if multiple providers?
    local provider="aws"

    local rootpath=""
    local configpath="config"
    local dirname="$(pwd)"
    if [ ! -f "provider.tf" ]; then
        echo "Searching for provider config"
        moduleroot
        rootpath=$(pwd)
        dirname=$(dirname $(find . -name "provider.tf" | head -n 1) 2>/dev/null)
        if [ -z "${dirname}" ]; then
            echo "Not a terraform module"
            return
        fi
        echo "Switching to ${dirname}"
        cd ${dirname}
    fi
    while [ ! -d ${configpath} ]; do
        configpath="../${configpath}"
    done

    local vpcs="control management services-be ssn-ingest www-ingest search"
    local terraform_commands="$($(which terraform) | sed -n '/^[ ]\+/p' | awk '{print $1}')"
    local environment=""
    local command="plan"
    local service=""
    local tfargs=()
    while [ ${#@} -gt 0 ]; do
        local argument=$1
        if contains ${argument} ${terraform_commands} setup kube reinit; then
            command=${argument}
        elif contains ${argument} $(
            find ${configpath} -name *.config -exec basename {} \; | \
                cut -d\. -f1 | tr "[:upper:]" "[:lower:]" | sort | uniq
        ); then
            environment=${argument}
        elif contains ${argument} "${vpcs}"; then
            service=${argument}
        else
            tfargs+=(${argument})
        fi
        shift
    done
    #privoxy ${environment}
    if [ -z ${environment} ]; then
        environment=$(mapbranch)
    fi
    local current_ws=$($(which terraform) workspace show)

    case ${command} in
        "setup")
            awssetup ${environment}
            tfinit ${environment}
            if [ ! -z ${service} ]; then
                onkube ${environment} ${service}
            fi
            return
            ;;
        "reinit")
            tf setup ${current_ws} $(basename ${KUBECONFIG%.config})
            return
            ;;
        "kube")
            ;;
        *)
            ;;
    esac
    local skiptfargs=(
        "validate"
        "output"
        "state"
    )
    if ! contains ${command} ${skiptfargs[@]}; then
        local vars_files=(
            "${configpath}/generic.tfvars"
            "${configpath}/${environment}.tfvars"
            "${configpath}/${provider}/generic.tfvars"
            "${configpath}/${provider}/${environment}.tfvars"
        )

        local region=$(grep -A1 'mss'${environment}']' ~/.aws/config | sed '1d;s/.*=\(.*\)/\1/')

        if contains ${command} plan apply validate; then
            tfargs+=(
                "-var region=${region}"
                "-var mss_env=${environment}"
            )
        fi

        if [ ${command} == 'apply' ]; then
            tfargs+=(
                "-auto-approve"
            )
        fi

        for file in ${vars_files[@]}; do
            if [ -f ${file} ]; then
                tfargs+=("-var-file=${file}")
            fi
        done
    fi

    if [ "${current_ws}" != "${environment}" ]; then
        echo "Current workspace '${current_ws}' != environment workspace '${environment}'"
        if [ "$(query "Do you want to switch to workspace ${environment}?" y n)" == 'y' ]; then
            tf setup ${environment} $(basename ${KUBECONFIG%-stack.config} | sed 's/sec-isecops-//')
        fi
    fi
    exec_command $(which terraform) ${command} ${tfargs[@]}
    local exit_code=$?
    cd ${cwd}
    return ${exit_code}
}

function tunnels()
{
    if [ ! -f ~/.config/tunnels.config ]; then
        return 0
    fi
    local netforward=1
    while IFS= read -r line ; do
        if [ "${line}" == 'netforward' ]; then
            netforward=0
            continue
        fi
        local bastion=$(cut -d: -f1 <<<${line})
        local port=$(cut -d: -f2 <<<${line})
        if [  ! -n "${bastion}" ]; then
            continue
        fi
        if ! ps aux | grep ".*NNTfq.*${port}" | grep -qv grep; then
            inform "Connecting to ${bastion} and forwarding ${port}"
            if [ ${netforward} -eq 1 ]; then
                ssh -NNTfq -o DynamicForward=${port} ${bastion}
            else
                ssh -NNTfq -L ${port}:localhost:${port} meteor.choclab.net
            fi
        fi
    done < ~/.config/tunnels.config
}

function orcaext ()
{
    if docker ps | grep --color=auto -q orcaext; then
        docker exec -it $(docker ps | grep orcaext | awk '{print $1}') /bin/bash;
    else
        docker run --rm --cpuset-cpus="0-15" -v /mnt/sequencer:/mnt/sequencer -d orcaext;
        orcaext;
    fi
}

function onchoclab() {
    cd "${HOME}/Archivo/src/cluster/nebula-cluster/pkg/infrastructure"
    vagrant ssh node1.choclab.net -- 'cat /etc/kubernetes/admin.conf' > ${HOME}/.kube/config
    cd - &>/dev/null
    kubectl describe secret $(kubectl get secrets | grep dashboard-admin-sa-token | awk '{print $1}') | grep token: | awk '{print $2}' | xclip -sel clip
    open "https://cluster.choclab.net"
    complete -W "$(k get ns | awk '!/NAME/{print $1}')" kc
    complete -W "$(k -n flux-system exec $(k get pods -n flux-system | grep source | awk '{print $1}') -- ls /data/gitrepository/default)" kcpgs
}

function ops() {
    local args="${@}"
    if [ ${#@} -eq 0 ]; then
        args="-h"
    fi
    export OPSCTL_GITHUB_TOKEN=$(bwv "development/github.com?field=full-access-token-never-expire" | jq -r .value)
    opsctl version update &>/dev/null
    opsctl ${args}
    unset OPSCTL_GITHUB_TOKEN
    if [ "$1" = 'login' ]; then
        complete -W "$(k get ns | awk '!/NAME/{print $1}')" kc
        if [ -n "$3" ]; then
            complete -W "$(k -n flux-system exec $(k get pods -n flux-system | grep source | awk '{print $1}') -- ls /data/gitrepository/default)" kcpgs
        fi
    fi
}

function kgs() {
    local args="${@}"
    if [ ${#@} -eq 0 ]; then
        args="-h"
    fi
    export OPSCTL_GITHUB_TOKEN=$(bwv "development/github.com?field=full-access-token-never-expire" | jq -r .value)
    kubectl gs selfupdate &>/dev/null
    kubectl gs ${args}
    unset OPSCTL_GITHUB_TOKEN
}

function kc() {
    k config set-context --current --namespace=$1
}

function kcpgs() {
    [ -d ${HOME}/src/gitrepos ] || mkdir ${HOME}/src/gitrepos
    cd ~/src/gitrepos
    rm -r ./*
    k cp -n flux-system $(k get pods -n flux-system | grep source | awk '{print $1}'):/data/gitrepository/default/$1 .
    tar -xvzf $(ls *.tar.gz)
}

function ssh() {
    local domain='choclab.net'
    local args=()
    broadcasthost send -d $domain &>/dev/null
    local islocal=$?
    sshcmd=$([ $islocal -eq 0 ] && echo 'ssh' || echo 'autossh')
    for a in $@; do
        if [ "${x#*\.*}" = "${domain}" ]; then
            case ${a%*.${domain}} in
                nebula)
                    ;&
                galaxy)
                    a=$([ $islocal -eq 0 ] && echo "nebula.${domain}" || echo "galaxy.${domain}")
                    ;;
            esac
        fi
        args+=($a)
    done
    $(which ${sshcmd}) "${args[@]}"
}

alias kl='kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind'
